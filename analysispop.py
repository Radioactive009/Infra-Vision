# -*- coding: utf-8 -*-
"""analysispop.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LltRS4ruLrPhp2TjlzPeAdKLtIbDQ1yx
"""

# ====== Cell 1: install (if needed) and imports ======
# Run this cell first. pandas and matplotlib are usually available in Colab.
!pip install openpyxl xlrd --quiet

import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from collections import Counter

# Matplotlib config: one plot per figure (we won't set colors/styles per instructions)
plt.rcParams['figure.figsize'] = (10,6)
plt.rcParams['font.size'] = 12

# ====== Cell 2: load the workbook, list sheets, auto-detect a main sheet ======
xls_path = "/content/annexure-1_wards_summary_of_population_pages_1_to_9 (1).xlsx"

# Check file exists
if not os.path.exists(xls_path):
    raise FileNotFoundError(f"File not found at {xls_path}. Upload to Colab and update the path.")

# Read workbook to see sheets
xls = pd.ExcelFile(xls_path)
print("Sheets found:", xls.sheet_names)

# Heuristic: pick the first sheet with a reasonable number of rows/columns
sheet_scores = {}
for sheet in xls.sheet_names:
    df_try = pd.read_excel(xls, sheet_name=sheet, nrows=10)
    sheet_scores[sheet] = df_try.shape[0] * df_try.shape[1]
# pick the sheet with the largest non-empty area
main_sheet = max(sheet_scores, key=sheet_scores.get)
print("Auto-selected sheet:", main_sheet)

# Load full sheet
df = pd.read_excel(xls, sheet_name=main_sheet)
df_original = df.copy()
print("Loaded shape:", df.shape)
display(df.head())

# ====== Cell 3: quick cleaning helpers & inspect columns ======
# Normalize column names: strip, lower, replace spaces
def normalize_cols(df):
    df = df.copy()
    df.columns = [str(c).strip() for c in df.columns]
    return df

df = normalize_cols(df)
print("Columns:")
for i,c in enumerate(df.columns):
    print(i, ":", c)

# Try to detect columns for ward name and population numbers using keywords
col_lower = [c.lower() for c in df.columns]
# common labels to search for
ward_candidates = [c for c in df.columns if any(k in c.lower() for k in ["ward","name","ward name","ward_no","ward no","ward no."])]
total_pop_candidates = [c for c in df.columns if any(k in c.lower() for k in ["total","population","pop","persons","popn"])]
male_candidates = [c for c in df.columns if "male" in c.lower()]
female_candidates = [c for c in df.columns if "female" in c.lower()]

print("\nWard column candidates:", ward_candidates)
print("Total population candidates:", total_pop_candidates)
print("Male candidates:", male_candidates)
print("Female candidates:", female_candidates)

# ====== Cell 4: set column names used for plotting (edit if mismatch) ======
# If auto-detection didn't find correct columns, change these manually.
# Example fallback names:
ward_col = ward_candidates[0] if ward_candidates else df.columns[0]   # fallback to first column
total_col = total_pop_candidates[0] if total_pop_candidates else None
male_col = male_candidates[0] if male_candidates else None
female_col = female_candidates[0] if female_candidates else None

print("Using columns:")
print("Ward column ->", ward_col)
print("Total population column ->", total_col)
print("Male column ->", male_col)
print("Female column ->", female_col)

# ====== Cell 5: create a clean numeric population column ======
# If there's a 'Total' column, coerce to numeric, else try to sum male+female if present.
df_plot = df.copy()

def to_numeric_safe(s):
    return pd.to_numeric(s, errors="coerce")

if total_col:
    df_plot['total_pop'] = to_numeric_safe(df_plot[total_col])
else:
    # try to sum male+female
    if male_col and female_col:
        df_plot['total_pop'] = to_numeric_safe(df_plot[male_col]) + to_numeric_safe(df_plot[female_col])
    else:
        # try infer columns that are numeric
        numeric_cols = [c for c in df_plot.columns if df_plot[c].dtype in [np.int64, np.float64]]
        if numeric_cols:
            df_plot['total_pop'] = df_plot[numeric_cols].select_dtypes(include=[np.number]).sum(axis=1)
        else:
            raise ValueError("Cannot find any numeric population column automatically. Please set `total_col`, `male_col`, `female_col` manually.")

# Ward name as string
df_plot['ward_name'] = df_plot[ward_col].astype(str)

# Drop rows with missing population
df_plot = df_plot.dropna(subset=['total_pop']).copy()
df_plot['total_pop'] = df_plot['total_pop'].astype(int)

print("Prepared dataframe shape:", df_plot.shape)
display(df_plot[['ward_name','total_pop']].head())

# ====== Cell 6: Basic summary and top/bottom wards ======
print("Total population (sum):", df_plot['total_pop'].sum())
print("Number of wards/rows:", df_plot.shape[0])
print("\nTop 10 wards by population:")
display(df_plot.sort_values('total_pop', ascending=False).head(10)[['ward_name','total_pop']])
print("\nBottom 10 wards by population:")
display(df_plot.sort_values('total_pop', ascending=True).head(10)[['ward_name','total_pop']])

# ====== Cell 7: Plot 1 — Bar chart: Total population per ward (top 15) ======
top_n = 15
df_top = df_plot.sort_values('total_pop', ascending=False).head(top_n).set_index('ward_name')
plt.figure(figsize=(12,6))
plt.bar(df_top.index, df_top['total_pop'])
plt.xticks(rotation=45, ha='right')
plt.title(f"Top {top_n} Wards by Total Population")
plt.ylabel("Population")
plt.tight_layout()
plt.savefig("/content/top_wards_population.png", dpi=150)
plt.show()
print("Saved: /content/top_wards_population.png")

# ====== Cell 8: Plot 2 — Horizontal bar chart for readability (all wards or top 30) ======
top_n = min(30, df_plot.shape[0])
df_plot_sorted = df_plot.sort_values('total_pop', ascending=True).set_index('ward_name')
df_plot_sorted.tail(top_n)['total_pop'].plot(kind='barh')
plt.xlabel("Population")
plt.title(f"Top {top_n} Wards (horizontal view)")
plt.tight_layout()
plt.savefig("/content/top_wards_population_h.png", dpi=150)
plt.show()
print("Saved: /content/top_wards_population_h.png")

# ====== Cell 9: If male and female columns exist — Stacked bar of gender distribution for top wards ======
if male_col and female_col:
    df_gender = df_plot.copy()
    df_gender['male'] = to_numeric_safe(df_gender[male_col]).fillna(0).astype(int)
    df_gender['female'] = to_numeric_safe(df_gender[female_col]).fillna(0).astype(int)
    top_n = 12
    dfg = df_gender.sort_values('total_pop', ascending=False).head(top_n).set_index('ward_name')
    plt.figure(figsize=(12,7))
    plt.bar(dfg.index, dfg['male'])
    plt.bar(dfg.index, dfg['female'], bottom=dfg['male'])
    plt.xticks(rotation=45, ha='right')
    plt.title("Gender distribution (Male / Female) — Top wards")
    plt.ylabel("Population")
    plt.tight_layout()
    plt.savefig("/content/gender_stack_top_wards.png", dpi=150)
    plt.show()
    print("Saved: /content/gender_stack_top_wards.png")
else:
    print("Male/Female columns not detected — skipping stacked gender chart. If present, set male_col/female_col variables.")

# ====== Cell 10: Pie chart — proportion of population among top 6 wards ======
top_n = 6
df_top6 = df_plot.sort_values('total_pop', ascending=False).head(top_n).set_index('ward_name')
plt.figure(figsize=(8,8))
plt.pie(df_top6['total_pop'], labels=df_top6.index, autopct='%1.1f%%', startangle=90)
plt.title(f"Population share — Top {top_n} wards")
plt.tight_layout()
plt.savefig("/content/top6_population_pie.png", dpi=150)
plt.show()
print("Saved: /content/top6_population_pie.png")

# ====== Cell 11: If the sheet has age-group columns, try to detect and plot age distribution ======
# heuristics: look for columns with patterns like '0-6', '0-5', 'age', 'children'
age_cols = [c for c in df_plot.columns if any(p in c.lower() for p in ['age','0-','0 to','0_','1-','children','0to'])]
age_cols = [c for c in age_cols if c not in ['total_pop']]  # remove accidental picks

if age_cols:
    print("Detected possible age columns:", age_cols)
    # sum across wards to get city-level age distribution
    age_series = df_plot[age_cols].apply(pd.to_numeric, errors='coerce').sum(axis=0)
    plt.figure(figsize=(10,5))
    plt.bar(age_series.index, age_series.values)
    plt.xticks(rotation=45, ha='right')
    plt.title("Aggregate Age-group distribution (detected columns)")
    plt.tight_layout()
    plt.savefig("/content/age_group_distribution.png", dpi=150)
    plt.show()
    print("Saved: /content/age_group_distribution.png")
else:
    print("No obvious age-group columns detected. If your file includes age buckets, edit the 'age_cols' list manually.")

# ====== Cell 12: Population density (if an 'Area' column exists) ======
area_candidates = [c for c in df_plot.columns if any(k in c.lower() for k in ['area','km','sq','sq.km','sq_km','hectare'])]
if area_candidates:
    area_col = area_candidates[0]
    df_plot['area'] = pd.to_numeric(df_plot[area_col], errors='coerce')
    df_plot['pop_density'] = df_plot['total_pop'] / df_plot['area']
    df_plot = df_plot.replace([np.inf, -np.inf], np.nan).dropna(subset=['pop_density'])
    df_plot_sorted = df_plot.sort_values('pop_density', ascending=False).head(15).set_index('ward_name')
    plt.figure(figsize=(12,6))
    plt.bar(df_plot_sorted.index, df_plot_sorted['pop_density'])
    plt.xticks(rotation=45, ha='right')
    plt.title("Population density (people per unit area) — Top 15")
    plt.ylabel("Population density")
    plt.tight_layout()
    plt.savefig("/content/pop_density_top15.png", dpi=150)
    plt.show()
    print("Saved: /content/pop_density_top15.png")
else:
    print("No 'area' like column detected. If you have area in sq km or hectares, set the area_col variable manually.")

import numpy as np

# show column names
print("Columns:", list(df.columns))

# print first rows so we see what's inside
display(df.head(10))

# show what the ward column variable currently is (if you used auto-detect earlier)
try:
    print("ward_col variable:", ward_col)
except NameError:
    print("ward_col not set yet")

# Inspect the values in the ward column candidate(s)
candidates = [c for c in df.columns if any(k in c.lower() for k in ["ward","name","ward name","ward_no","ward no"])]
print("Detected ward column candidates:", candidates)

if candidates:
    c = candidates[0]
    print("Sample values for column:", c)
    display(df[c].head(20))
    print("dtype:", df[c].dtype)
    print("null count:", df[c].isna().sum())
    # show unique sample items
    print("Unique sample values (first 30):", df[c].dropna().astype(str).str.strip().unique()[:30])
else:
    print("No obvious ward column candidate found. Show first 10 columns and values:")
    for col in df.columns[:10]:
        print(col, df[col].dtype, "nulls:", df[col].isna().sum())
        display(df[[col]].head(5))

import pandas as pd
import numpy as np
import re
import matplotlib.pyplot as plt

# assume df is already loaded as before
print("Initial shape:", df.shape)
print("Columns:", list(df.columns))

# set the columns we will use
ward_col = "Ward Name"
total_col = "Total Population"

# preview the two columns
display(df[[ward_col, total_col]].head(15))

# --- CLEAN ward names ---
# convert to string, strip whitespace, replace literal 'nan' strings with np.nan
df[ward_col] = df[ward_col].astype(str).str.strip()
df[ward_col] = df[ward_col].replace({'nan': np.nan, 'None': np.nan, '': np.nan})

# remove rows where ward column contains words that indicate summary/total rows
# e.g. 'Total', 'AC', 'Total Population', 'AC 1 Total Population :'
mask_summary = df[ward_col].astype(str).str.contains(
    r'(?i)\b(total|ac\s*\d+|ac\s*total|total population|population :)\b', regex=True, na=False
)
print("Rows flagged as summary (example):", df[mask_summary].head(6))

# keep rows that are NOT summary and have a non-null ward name
df_clean = df[~mask_summary].copy()
print("After removing summary rows shape:", df_clean.shape)

# --- CLEAN population column ---
# Show a sample of odd population strings
pop_sample = df_clean[total_col].astype(str).head(30)
print("Sample total population raw values:")
display(pop_sample)

# Extract digits only (first continuous digits sequence). This handles values like '116B9' -> '1169' (or best-effort)
def extract_digits(val):
    s = str(val)
    # find all digits, join them; if none return NaN
    digits = re.findall(r'\d+', s)
    if digits:
        return int(''.join(digits))
    return np.nan

df_clean['total_pop_raw'] = df_clean[total_col]
df_clean['total_pop'] = df_clean[total_col].apply(extract_digits)

# Count how many became numeric vs NaN
print("Converted total_pop - non-null count:", df_clean['total_pop'].notna().sum(), "/", len(df_clean))

# Drop rows where total_pop is NaN (cannot plot without numeric population)
df_clean = df_clean.dropna(subset=['total_pop']).copy()
df_clean['total_pop'] = df_clean['total_pop'].astype(int)

# Final clean ward names: strip again and remove empty strings
df_clean[ward_col] = df_clean[ward_col].astype(str).str.strip()
df_clean = df_clean[~df_clean[ward_col].isin([None, '', 'nan'])]

print("Final cleaned shape:", df_clean.shape)
display(df_clean[[ward_col, 'total_pop']].head(20))

# Save cleaned CSV for inspection if you want
df_clean.to_csv('/content/wards_population_cleaned.csv', index=False)
print("Saved cleaned data to /content/wards_population_cleaned.csv")

import pandas as pd
import numpy as np
import re
import matplotlib.pyplot as plt

# assume df is already loaded as before
print("Initial shape:", df.shape)
print("Columns:", list(df.columns))

# set the columns we will use
ward_col = "Ward Name"
total_col = "Total Population"

# preview the two columns
display(df[[ward_col, total_col]].head(15))

# --- CLEAN ward names ---
# convert to string, strip whitespace, replace literal 'nan' strings with np.nan
df[ward_col] = df[ward_col].astype(str).str.strip()
df[ward_col] = df[ward_col].replace({'nan': np.nan, 'None': np.nan, '': np.nan})

# remove rows where ward column contains words that indicate summary/total rows
# e.g. 'Total', 'AC', 'Total Population', 'AC 1 Total Population :'
mask_summary = df[ward_col].astype(str).str.contains(
    r'(?i)\b(total|ac\s*\d+|ac\s*total|total population|population :)\b', regex=True, na=False
)
print("Rows flagged as summary (example):", df[mask_summary].head(6))

# keep rows that are NOT summary and have a non-null ward name
df_clean = df[~mask_summary].copy()
print("After removing summary rows shape:", df_clean.shape)

# --- CLEAN population column ---
# Show a sample of odd population strings
pop_sample = df_clean[total_col].astype(str).head(30)
print("Sample total population raw values:")
display(pop_sample)

# Extract digits only (first continuous digits sequence). This handles values like '116B9' -> '1169' (or best-effort)
def extract_digits(val):
    s = str(val)
    # find all digits, join them; if none return NaN
    digits = re.findall(r'\d+', s)
    if digits:
        return int(''.join(digits))
    return np.nan

df_clean['total_pop_raw'] = df_clean[total_col]
df_clean['total_pop'] = df_clean[total_col].apply(extract_digits)

# Count how many became numeric vs NaN
print("Converted total_pop - non-null count:", df_clean['total_pop'].notna().sum(), "/", len(df_clean))

# Drop rows where total_pop is NaN (cannot plot without numeric population)
df_clean = df_clean.dropna(subset=['total_pop']).copy()
df_clean['total_pop'] = df_clean['total_pop'].astype(int)

# Final clean ward names: strip again and remove empty strings
df_clean[ward_col] = df_clean[ward_col].astype(str).str.strip()
df_clean = df_clean[~df_clean[ward_col].isin([None, '', 'nan'])]

print("Final cleaned shape:", df_clean.shape)
display(df_clean[[ward_col, 'total_pop']].head(20))

# Save cleaned CSV for inspection if you want
df_clean.to_csv('/content/wards_population_cleaned.csv', index=False)
print("Saved cleaned data to /content/wards_population_cleaned.csv")

import re
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# assume df is loaded and ward_col/total_col set as before
ward_col = "Ward Name"
total_col = "Total Population"

df_work = df.copy()

# 1) remove summary rows (as before)
mask_summary = df_work[ward_col].astype(str).str.contains(
    r'(?i)\b(total|ac\s*\d+|ac\s*total|total population|population :)\b', regex=True, na=False
)
df_work = df_work[~mask_summary].copy()

# 2) define OCR mapping and helper functions
ocr_map = {
    'B':'8', 'b':'8',
    'O':'0', 'o':'0', 'Q':'0',
    'I':'1', 'l':'1', '|' : '1',
    'S':'5', 's':'5',
    'Z':'2', 'z':'2',
    'G':'6', 'g':'9',  # g ambiguous; careful
    'D':'0', 'P':'' , '?':'', ',':'', ' ':'', 'A':'4'
}
# Note: mapping is heuristic. We'll try conservative replacements.

def apply_ocr_map(s):
    s = str(s)
    # if it's already mostly digits, return raw
    if re.search(r'\d', s):
        # apply mapping char-by-char for non-digit chars
        out_chars = []
        for ch in s:
            if ch.isdigit():
                out_chars.append(ch)
            elif ch in ocr_map:
                out_chars.append(ocr_map[ch])
            else:
                # replace common accidental characters with nothing
                out_chars.append('')
        return ''.join(out_chars)
    return ''

def extract_number_best_effort(raw):
    s = str(raw)
    # 1: try naive extraction of digits groups (original approach)
    digits_groups = re.findall(r'\d+', s)
    if digits_groups:
        # choose longest group (likely the full population)
        longest = max(digits_groups, key=len)
        val = int(longest)
        # if plausible (>=1000), accept
        if val >= 1000:
            return val
    # 2: try OCR mapping then extract digits
    s_mapped = apply_ocr_map(s)
    digits_groups2 = re.findall(r'\d+', s_mapped)
    if digits_groups2:
        longest2 = max(digits_groups2, key=len)
        val2 = int(longest2)
        if val2 >= 1000:
            return val2
        # if it's small but >0, keep as candidate (we'll flag later)
        if val2 > 0:
            return val2
    # 3: fallback: if original has multiple small digit groups, join them
    if digits_groups:
        joined = int(''.join(digits_groups))
        if joined >= 1000:
            return joined
        if joined > 0:
            return joined
    # 4: as last resort, try to keep first numeric group even if small
    if digits_groups2:
        return int(digits_groups2[0])
    return np.nan

# 3) apply function to create numeric column
df_work[total_col] = df_work[total_col].astype(str)
df_work['total_pop_candidate'] = df_work[total_col].apply(extract_number_best_effort)

# 4) identify suspicious rows: candidate is NaN or < 1000 (threshold adjustable)
suspicious = df_work[(df_work['total_pop_candidate'].isna()) | (df_work['total_pop_candidate'] < 1000)].copy()
suspicious_display = suspicious[[ward_col, total_col, 'total_pop_candidate']].reset_index(drop=True)
print("Number of suspicious rows (NaN or <1000):", suspicious_display.shape[0])
display(suspicious_display.head(40))

# Save suspicious to CSV so you can edit manually if you want
suspicious_display.to_csv('/content/wards_population_suspicious.csv', index=False)
print("Saved suspicious rows to /content/wards_population_suspicious.csv")
print("Open that CSV, fix the 'total_pop_candidate' values where you know the true population, then re-upload or edit directly in the notebook.")

# 5) For plotting, keep rows where candidate is present and >= 1000
df_good = df_work[df_work['total_pop_candidate'].notna()].copy()
df_good['total_pop'] = df_good['total_pop_candidate'].astype(int)

# Optionally, drop tiny populations if they seem wrong
# df_good = df_good[df_good['total_pop'] >= 1000]

print("Rows ready for plotting:", df_good.shape[0])
display(df_good[[ward_col,'total_pop']].head(30))

# 6) Plot using cleaned values (top 30 horizontal)
df_plot = df_good.rename(columns={ward_col:'ward_name'}).copy()
df_plot = df_plot[~df_plot['ward_name'].isna()]
df_plot_sorted = df_plot.sort_values('total_pop', ascending=True).set_index('ward_name')
top_n = min(30, df_plot_sorted.shape[0])
plt.figure(figsize=(12,10))
df_plot_sorted.tail(top_n)['total_pop'].plot(kind='barh')
plt.xlabel("Population")
plt.title(f"Top {top_n} Wards (horizontal view) — after OCR cleanup")
plt.tight_layout()
plt.show()

# 7) Pie chart top 6
top_n2 = 6
df_top6 = df_plot.sort_values('total_pop', ascending=False).head(top_n2)
plt.figure(figsize=(8,8))
plt.pie(df_top6['total_pop'], labels=df_top6['ward_name'], autopct='%1.1f%%', startangle=90)
plt.title(f"Population share — Top {top_n2} wards")
plt.tight_layout()
plt.show()

plt.figure(figsize=(10,6))
plt.hist(df_good['total_pop'], bins=25)
plt.xlabel("Ward population")
plt.ylabel("Number of wards")
plt.title("Distribution of ward populations")
plt.tight_layout()
plt.savefig("/content/population_histogram.png", dpi=150)
plt.show()
print("Saved: /content/population_histogram.png")

import numpy as np
plt.figure(figsize=(10,6))
plt.hist(np.log1p(df_good['total_pop']), bins=30)
plt.xlabel("log(1 + population)")
plt.ylabel("Number of wards")
plt.title("Log-transformed ward population distribution")
plt.tight_layout()
plt.savefig("/content/population_hist_log.png", dpi=150)
plt.show()
print("Saved: /content/population_hist_log.png")

plt.figure(figsize=(8,4))
plt.boxplot(df_good['total_pop'], vert=False)
plt.xlabel("Ward population")
plt.title("Boxplot of ward populations")
plt.tight_layout()
plt.savefig("/content/population_boxplot.png", dpi=150)
plt.show()
print("Saved: /content/population_boxplot.png")

# Lorenz curve & Gini
pop = np.sort(df_good['total_pop'].values)
cum_pop = np.cumsum(pop)
cum_pop_norm = cum_pop / cum_pop[-1]
n = len(pop)
x = np.linspace(1/n, 1, n)

plt.figure(figsize=(8,8))
plt.plot(np.insert(np.linspace(0,1,n),0,0), np.insert(cum_pop_norm,0,0), label='Lorenz curve')
plt.plot([0,1],[0,1], '--', label='Line of equality')
plt.xlabel("Cumulative share of wards")
plt.ylabel("Cumulative share of population")
plt.title("Lorenz curve — population inequality across wards")
plt.legend()
plt.tight_layout()
plt.savefig("/content/lorenz_population.png", dpi=150)
plt.show()
print("Saved: /content/lorenz_population.png")

# Gini
lorenz = np.insert(cum_pop_norm,0,0)
B = np.trapz(lorenz, dx=1.0/len(lorenz))  # area under lorenz
Gini = 1 - 2 * B
print("Estimated Gini coefficient (0=equal,1=max):", round(Gini,3))

if 'AC  Name' in df_good.columns:
    ac_pop = df_good.groupby('AC  Name')['total_pop'].sum().sort_values(ascending=False)
    top_ac = ac_pop.head(20)
    plt.figure(figsize=(12,6))
    plt.bar(top_ac.index, top_ac.values)
    plt.xticks(rotation=45, ha='right')
    plt.ylabel("Total population")
    plt.title("Top 20 ACs by combined ward population")
    plt.tight_layout()
    plt.savefig("/content/top_ac_population.png", dpi=150)
    plt.show()
    print("Saved: /content/top_ac_population.png")
else:
    print("Column 'AC  Name' not present — skipping AC aggregation.")

df_sorted_desc = df_good.sort_values('total_pop', ascending=False).reset_index(drop=True)
df_sorted_desc['cum_pop_perc'] = df_sorted_desc['total_pop'].cumsum() / df_sorted_desc['total_pop'].sum() * 100
plt.figure(figsize=(12,6))
ax = plt.gca()
ax.bar(df_sorted_desc.index+1, df_sorted_desc['total_pop'])
ax2 = ax.twinx()
ax2.plot(df_sorted_desc.index+1, df_sorted_desc['cum_pop_perc'], color='orange', marker='o', markersize=3)
ax.set_xlabel("Wards (ranked by population)")
ax.set_ylabel("Population")
ax2.set_ylabel("Cumulative population (%)")
plt.title("Pareto: Ward population and cumulative share")
ax.set_yscale('linear')
plt.tight_layout()
plt.savefig("/content/pareto_wards_population.png", dpi=150)
plt.show()
print("Saved: /content/pareto_wards_population.png")

if 'SC\nPopulation' in df_work.columns or 'SC\nPopulation' in df_good.columns:
    # adapt name - ensure numeric column exists
    if 'SC_pop' not in df_good.columns:
        # try to create from df_good if possible (best-effort)
        def digits_only(x):
            import re
            g = re.findall(r'\d+', str(x))
            return int(''.join(g)) if g else np.nan
        df_good['SC_pop'] = df_good['SC\nPopulation'].apply(digits_only)
    plt.figure(figsize=(8,6))
    plt.scatter(df_good['total_pop'], df_good['SC_pop'])
    plt.xlabel("Total population")
    plt.ylabel("SC population")
    plt.title("SC population vs total population by ward")
    plt.tight_layout()
    plt.savefig("/content/sc_vs_total_scatter.png", dpi=150)
    plt.show()
    print("Saved: /content/sc_vs_total_scatter.png")
else:
    print("SC population column not found or not cleaned — skipping SC scatter.")

!pip install wordcloud --quiet

from wordcloud import WordCloud, STOPWORDS

text = " ".join(df_good[ward_col].astype(str).tolist())
wc = WordCloud(width=800, height=400, background_color='white', collocations=False).generate(text)
plt.figure(figsize=(14,6))
plt.imshow(wc, interpolation='bilinear')
plt.axis('off')
plt.title("Word cloud of ward names")
plt.tight_layout()
plt.savefig("/content/wardname_wordcloud.png", dpi=150)
plt.show()
print("Saved: /content/wardname_wordcloud.png")